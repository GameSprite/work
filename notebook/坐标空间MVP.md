1. 在**顶点转换为片段**之前，它会处于一下几个不同的状态

   1. 局部空间(Local Space，或者称为物体空间(Object Space))
   2. 世界空间(World Space)
   3. 观察空间(View Space，或者称为视觉空间(Eye Space))和摄像机
   4. 裁剪空间(Clip Space)
   5. 屏幕空间(Screen Space)

2. 为了将坐标从一个坐标系转换到另一个坐标系，我们需要用到几个转换矩阵，最重要的几个分别是**模型(Model)**、**视图(View)**、**投影(Projection)**三个矩阵。首先，顶点坐标开始于**局部空间(Local Space)**，称为**局部坐标(Local Coordinate)**，然后经过**世界坐标(World Coordinate)**，**观察坐标(View Coordinate)**，**裁剪坐标(Clip Coordinate)**，并最后以**屏幕坐标(Screen Coordinate)**结束。下面的图示显示了整个流程及各个转换过程做了什么：

   ![coordinate_systems](note_pic/coordinate_systems.png)

3. 由投影矩阵创建的**观察区域(Viewing Box)**被称为**平截头体(Frustum)**，且每个出现在平截头体范围内的坐标都会最终出现在用户的屏幕上。将一定范围内的坐标转化到标准化设备坐标系的过程(而且它很容易被映射到2D观察空间坐标)被称之为**投影(Projection)**，因为使用投影矩阵能将3维坐标**投影(Project)**到很容易映射的2D标准化设备坐标系中。

   一旦所有顶点被转换到裁剪空间，最终的操作——**透视划分(Perspective Division)**将会执行，在这个过程中我们将位置向量的x，y，z分量分别除以向量的齐次w分量；透视划分是将4维裁剪空间坐标转换为3维标准化设备坐标。这一步会在每一个顶点着色器运行的最后被自动执行。

   在这一阶段之后，坐标经过转换的结果将会被映射到屏幕空间(由`glViewport`设置)且被转换成片段。

   投影矩阵将观察坐标转换为裁剪坐标的过程采用两种不同的方式，每种方式分别定义自己的平截头体。我们可以创建一个正射投影矩阵(Orthographic Projection Matrix)或一个透视投影矩阵(Perspective Projection Matrix)。

   - 正射投影
     正射投影创建的平截头体是一个长方体，其中的每一个顶点离我们的眼睛的距离都是一样的，也就是，没有透视效果,不是很真实。使用一下方法可以创建一个正射投影矩阵:

     ```c++
     glm::ortho(0.0f, 800.0f, 0.0f, 600.0f, 0.1f, 100.0f);
     //前4个参数分别是正射头体的左右底上坐标，参5参6是近平面和远平面距离
     ```

   - 透视投影

     透视投影模仿现实的近大远小。**这个投影矩阵不仅将给定的平截头体范围映射到裁剪空间，同样还修改了每个顶点坐标的w值，从而使得离观察者越远的顶点坐标w分量越大。**被转换到裁剪空间的坐标都会在-w到w的范围之间(任何大于这个范围的对象都会被裁剪掉)。OpenGL要求所有可见的坐标都落在-1.0到1.0范围内从而作为最后的顶点着色器输出，因此一旦坐标在裁剪空间内，透视划分就会被应用到裁剪空间:
     $$
     out = (x/w , y/w, z/w)
     $$
     在GLM中可以这样创建一个投影矩阵：

     ```c++
     glm::mat4 proj = glm::perspective(45.0f,(float)width/(float)height,0.1f,100.0f)
     ```

     ![perspective_frustum](note_pic/perspective_frustum.png)

     参数1:就是FOV(Field of View)表示视野

     参数2：宽高比

     参数3,4就是近平面和远平面的距离

   4.三个变换矩阵的组合

   我们为上述的每一个步骤都创建了一个转换矩阵：模型矩阵、观察矩阵和投影矩阵。一个顶点的坐标将会根据以下过程被转换到裁剪坐标：
   $$
   \mathbf{V}clip= \mathbf{M}projection\cdot\mathbf{M}view\cdot\mathbf{M}local\cdot\mathbf{V}local
   $$
   注意每个矩阵被运算的顺序是相反的(记住我们需要从右往左乘上每个矩阵)。最后的顶点应该被赋予顶点着色器中的`gl_Position`且OpenGL将会自动进行透视划分和裁剪。

   **顶点着色器的输出要求要在剪裁空间里边，三个转换矩阵做到了这一点**

   **接下来**:OpenGL在裁剪空间中执行透视划分从而将它们转换到标准化设备坐标。OpenGL会使用`glViewPort`内部的参数来将标准化设备坐标映射到屏幕坐标，每个坐标都关联了一个屏幕上的点(在我们的例子中屏幕是800 *600)。这个过程称为视口转换。

   ​

   ​
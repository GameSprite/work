#### **光照基础**

------

现实世界的光照是极其复杂的，而且会受到诸多因素的影响，这是以目前我们所拥有的处理能力无法模拟的。因此OpenGL的光照仅仅使用了简化的模型并基于对现实的估计来进行模拟，这样处理起来会更容易一些，而且看起来也差不多一样。这些光照模型都是基于我们对光的物理特性的理解。其中一个模型被称为冯氏光照模型(Phong Lighting Model)。冯氏光照模型的主要结构由3个元素组成：**环境**(Ambient)、**漫反射**(Diffuse)和**镜面**(Specular)**光照**。这些光照元素看起来像下面这样.

![basic_lighting_phong](note_pic/basic_lighting_phong.png)

- 环境光照(Ambient lighting),物体随时都会被反射自环境中的光照射到，所以永远不会黑暗，我们使用环境光照来模拟这一情况，也就是说永远给物体一些颜色。
- 漫反射(Diffuse)光照，模拟一个发光物对物体的方向性影响(Directional Impact)。它是冯氏光照模型最显著的组成部分。面向光源的一面比其他面会更亮。
- 镜面(Specular)光照,模拟有光泽物体上面出现的亮点。镜面光照的颜色，相比于物体的颜色更倾向于光的颜色。

#### *环境光照*

光通常都不是来自于同一光源，而是来自散落于我们周围的很多光源，即使它们可能并不是那么显而易见。光的一个属性是，它可以向很多方向发散和反弹，所以光最后到达的地点可能并不是它所临近的直射方向；光能够像这样**反射(Reflect)**到其他表面，一个物体的光照可能受到来自一个非直射的光源影响。考虑到这种情况的算法叫做**全局照明(Global Illumination)**算法，但是这种算法既开销高昂又极其复杂。

因为我们不是复杂和昂贵算法的死忠粉丝，所以我们将会使用一种简化的全局照明模型，叫做环境光照(Ambient Lighting)。如你在前面章节所见，我们使用一个(数值)很小的常量(光)颜色添加进物体**片段**(Fragment，指当前讨论的光线在物体上的照射点)的最终颜色里，这看起来就像即使没有直射光源也始终存在着一些发散的光。

```c++
void main()
{
    float ambientStrength = 0.1f; //环境光照因子
    vec3 ambient = ambientStrength * lightColor;//环境光色
    vec3 result = ambient * objectColor;//使用环境光乘以物体颜色获取物体反射的颜色
    color = vec4(result, 1.0f);
}
```

#### *漫反射光照*

如果光线垂直于物体表面，这束光对物体的影响会最大化(译注：更亮)。为了测量光线和片段的角度，我们使用一个叫做法向量(Normal Vector)的东西，它是垂直于片段表面的一种向量，两个向量之间的角度就能够根据点乘计算出来。**顶点法向量一般会作为顶点的属性来读入。**

下为计算光线向量：

```c++
in vec3 Normal;//片段法向量
in vec3 FragPos;//片段位置向量

void main()
{
	vec3 norm = normalize(Normal);//注意标准化
	vec3 lightDir = normalize(lightPos - FragPos);
}
```

> 当计算光照时我们通常不关心一个向量的“量”或它的位置，我们只关心它们的方向。所有的计算都使用单位向量完成，因为这会简化了大多数计算(比如点乘)。所以当进行光照计算时，确保你总是对相关向量进行标准化，这样它们才会保证自身为单位向量。忘记对向量进行标准化是一个十分常见的错误。

下一步，我们对`norm`和`lightDir` 进行点乘(求内积)，来计算光对当前片段的实际散射影响。结果值再乘以光的颜色，得到散射因子。两个向量之间的角度越大，散射因子就会越小：

```c++
float diff = max(dot(norm,lightDir),0);
float diffuse = diff * lightColor;
```

```c++
//最后的光照颜色结果就是
color = vec4((diffuse + ambient) * objectColor,1.0f);
```

#### *镜面光照*

当观察者的眼睛越靠近物体反射光时，光线感受更强，向镜子一样。

镜面光照因子的计算会依靠一下几个元素:

- 反射光线方向向量
- 观察方向向量(视线方向向量的负方向)
- 片段法线向量
- 镜面光照强度
- 物体发光值(物体的发光值越高，反射光的能力越强，散射得越少，高光点越小)

```c++
float specularStrength = 0.5f;//镜面光照强度
vec3 viewDir = normalize(viewPos - FragPos);//视线方向向量 反
vec3 relectDir = reflect(-lightDir,norm);//反射光线方向

float spec = pow(max(dot(relectDir,viewDir),0),32);//获取镜面亮度分量,32是物体的发光值，发光值越高，越接近镜子
vec3 specular = specularStrength * spec * lightColor; //获取镜面光照
```

> 早期的光照着色器，开发者在顶点着色器中实现冯氏光照。相比于在片段着色器中实现光照，顶点的数量要比片段多得多，这种方式会更高效，所以开销大的光照计算频率会更低。。然而，顶点着色器中的颜色值是只是顶点的颜色值，片段的颜色值是它与周围的颜色值的插值。结果就是这种光照看起来不会非常真实，除非使用了大量顶点。
>
> 在顶点着色器中实现的冯氏光照模型叫做Gouraud着色，而不是Phong冯氏着色。记住由于插值，这种光照连起来有点逊色。冯氏着色能产生更平滑的光照效果。

